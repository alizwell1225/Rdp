# RpcClient 和 RpcServer 增強功能說明

## 問題回顧

根據您提出的需求，我已完成以下工作：

### 1. ✅ 審查和完善 Lib_Define 資料

**ClassObj.cs 增強內容：**
- 為 `FlowChartOBJ` 添加了 JSON 序列化支援
- 添加 `WorkList_ColorArgb` 屬性用於 JSON 相容的顏色序列化
  - 原本的 `WorkList_Color` (List<Color>) 無法直接序列化為 JSON
  - 新增 `WorkList_ColorArgb` (List<int>) 儲存 ARGB 值供 JSON 使用
- 添加輔助方法：
  - `SyncColorsToArgb()`: 發送前將 Color 轉換為 ARGB
  - `SyncColorsFromArgb()`: 接收後將 ARGB 轉換回 Color
- 新增 `ImageTransferMessage` 類別用於圖片傳輸

**ShowPictureType 枚舉：**
- 保持完整，包含 None, Flow, Map 三種類型
- 用於識別圖片用途

### 2. ✅ 確認和增強 RpcClient

**新增的泛型方法：**
```csharp
// 發送任何可序列化的物件
Task<JsonAcknowledgment> SendObjectAsJsonAsync<T>(string type, T obj, CancellationToken ct = default)

// 發送 FlowChartOBJ
Task<JsonAcknowledgment> SendFlowChartAsync(FlowChartOBJ flowChart, CancellationToken ct = default)

// 反序列化收到的 JSON 訊息
T? DeserializeJsonMessage<T>(JsonMessage message) where T : class
```

**新增的圖片接收功能：**
```csharp
// 接收圖片資料的事件
public Action<int, ShowPictureType, Image> ActionOnServerImage;

// 接收圖片路徑的事件
public Action<int, ShowPictureType, string> ActionOnServerImagePath;
```

**自動處理圖片訊息：**
- `apiOnServerJson` 方法已增強，會自動檢測並處理 "image" 類型訊息
- 支援兩種圖片傳輸方式：路徑或 Base64 編碼資料

### 3. ✅ 建立 RpcServer 內容

**完整實作 RpcServer 類別：**

RpcServer 參考 GrpcServerApp (ServerForm) 的功能，但完全脫離 UI 介面，可用於：
- Console 應用程式
- Windows Service
- Web 後端服務
- 任何不需要 WinForms 的場景

**主要功能：**
```csharp
// 伺服器控制
Task StartAsync()
Task StopAsync()
void UpdateConfig(string host, int port)

// 檔案操作
Task<(bool Success, string Error)> PushFileAsync(string filePath, bool useAckMode = true, CancellationToken ct = default)
string[] GetFiles()

// JSON 廣播
Task<(bool Success, int ClientsReached, string Error)> BroadcastJsonAsync(string type, string json, bool useAckMode = true, CancellationToken ct = default)

// 統計資訊
(int TotalRequests, int TotalBytes, TimeSpan Runtime) GetStatistics()
void ResetStatistics()
```

**事件系統：**
```csharp
public Action<int, string>? ActionOnLog;
public Action<int, string>? ActionOnFileAdded;
public Action<int, string>? ActionOnFileUploadCompleted;
public Action<int, string>? ActionOnClientConnected;
public Action<int, string>? ActionOnClientDisconnected;
public Action<int, string, int>? ActionOnBroadcastSent;
// 等等...
```

### 4. ✅ 雙向 FlowChartOBJ JSON 傳輸

**RpcServer 發送 FlowChartOBJ：**
```csharp
var flowChart = new FlowChartOBJ 
{ 
    ID = 1, 
    Type = "Process",
    Caption = "測試流程"
};

// 自動將顏色同步到 ARGB 並廣播
var result = await server.BroadcastFlowChartAsync(flowChart, useAckMode: true);
Console.WriteLine($"發送成功: {result.Success}, 到達客戶端: {result.ClientsReached}");
```

**RpcClient 接收 FlowChartOBJ：**
```csharp
client.ActionOnServerJson += (index, jsonMsg) =>
{
    if (jsonMsg.Type == "flowchart")
    {
        var flowChart = client.DeserializeJsonMessage<FlowChartOBJ>(jsonMsg);
        if (flowChart != null)
        {
            // 顏色已自動從 ARGB 同步回來
            Console.WriteLine($"收到流程圖: ID={flowChart.ID}");
            foreach (var color in flowChart.WorkList_Color)
            {
                Console.WriteLine($"顏色: {color.Name}");
            }
        }
    }
};
```

**RpcClient 發送 FlowChartOBJ 回 Server：**
```csharp
var flowChart = new FlowChartOBJ 
{ 
    ID = 2, 
    Type = "Response" 
};

var ack = await client.SendFlowChartAsync(flowChart);
Console.WriteLine($"發送成功: {ack.Success}");
```

### 5. ✅ RpcServer 圖片傳輸功能

**方式一：使用路徑傳送**
```csharp
var result = await server.BroadcastImageByPathAsync(
    ShowPictureType.Flow,           // 圖片類型
    @"C:\images\flowchart.png",     // 圖片路徑
    useAckMode: true
);
```

**方式二：使用 Image 物件傳送**
```csharp
using var image = Image.FromFile(@"C:\images\map.png");
// 或者程式產生的圖片
// using var image = new Bitmap(800, 600);

var result = await server.BroadcastImageAsync(
    ShowPictureType.Map,            // 圖片類型
    image,                          // Image 物件
    fileName: "map.png",
    useAckMode: true
);
```

**RpcClient 接收圖片：**
```csharp
// 接收圖片資料
client.ActionOnServerImage += (index, pictureType, image) =>
{
    Console.WriteLine($"收到圖片: 類型={pictureType}, 大小={image.Width}x{image.Height}");
    // 使用圖片...
    image.Save($@"C:\temp\received_{pictureType}.png");
};

// 接收圖片路徑
client.ActionOnServerImagePath += (index, pictureType, path) =>
{
    Console.WriteLine($"收到圖片路徑: 類型={pictureType}, 路徑={path}");
    using var image = Image.FromFile(path);
    // 使用圖片...
};
```

## 泛型支援確認

**是的，兩邊都可以使用泛型！**

**RpcServer 泛型方法：**
```csharp
// 廣播任何可序列化的物件
public async Task<(bool Success, int ClientsReached, string Error)> BroadcastObjectAsync<T>(
    string type, 
    T obj, 
    bool useAckMode = true, 
    CancellationToken ct = default)
```

**RpcClient 泛型方法：**
```csharp
// 發送任何可序列化的物件
public async Task<JsonAcknowledgment> SendObjectAsJsonAsync<T>(
    string type, 
    T obj, 
    CancellationToken ct = default)

// 反序列化任何類型
public T? DeserializeJsonMessage<T>(JsonMessage message) where T : class
```

**使用範例：**
```csharp
// 定義自訂類別
public class MyData
{
    public int Id { get; set; }
    public string Name { get; set; }
    public List<string> Items { get; set; }
}

// Server 發送
var data = new MyData { Id = 1, Name = "測試", Items = new List<string> { "A", "B" } };
await server.BroadcastObjectAsync("my_data", data);

// Client 接收
client.ActionOnServerJson += (index, jsonMsg) =>
{
    if (jsonMsg.Type == "my_data")
    {
        var data = client.DeserializeJsonMessage<MyData>(jsonMsg);
        Console.WriteLine($"收到資料: {data?.Name}");
    }
};

// Client 發送
await client.SendObjectAsJsonAsync("my_response", new MyData { Id = 2, Name = "回應" });
```

## 完整使用範例

詳細的使用範例和說明文件已建立：
1. **README_RpcUsage.md** - 完整使用手冊（英文）
2. **ExampleUsage.cs** - 程式碼範例

## 技術細節

### JSON 序列化
- 使用 `System.Text.Json` 進行序列化
- 支援複雜物件、集合、巢狀結構
- FlowChartOBJ 的 Color 自動轉換為 ARGB 整數

### 圖片傳輸
- **路徑方式**：適用於區域網路，效率高
- **資料方式**：使用 Base64 編碼，適用於任何網路環境

### 執行緒安全
- 兩個類別都使用內部執行緒同步
- 事件處理器可能在不同執行緒被呼叫
- 建議在處理器中確保執行緒安全

## 總結

所有需求已完成實作：

1. ✅ Lib_Define 已審查並增強（JSON 序列化、顏色轉換）
2. ✅ RpcClient 已確認並補充（泛型方法、圖片接收）
3. ✅ RpcServer 已建立完整內容（參考 GrpcServerApp，脫離 UI）
4. ✅ FlowChartOBJ 可雙向傳輸（泛型支援）
5. ✅ 圖片傳輸功能（路徑 + Image 物件）

所有功能都已測試設計，可以直接使用於您的專案中！
